# Agent Prompt – M1: markdown-extract PyO3 Bindings

**Agent ID**: Agent 1  
**Milestone**: M1 – Extract Bindings  
**Target Date**: 2025-11-04  
**Estimated Effort**: 3-4 days

---

## Objective

Implement Python bindings for `markdown-extract` using PyO3, exposing the core extraction functionality through an idiomatic Python API. This milestone delivers the foundation for Python-based MCP integration.

---

## Scope

### In Scope
1. **New crate**: `crates/markdown_extract_py` with PyO3 bindings
2. **Core extraction API**:
   - `extract(pattern: str, content: str, **options) -> List[str]`
   - `extract_from_file(pattern: str, path: str, **options) -> List[str]`
   - Support flags: `case_sensitive`, `all_matches`, `no_heading`
   - `no_heading` is implemented in the binding layer (drop heading line after joining)
3. **Structured output** (optional): `Section` dataclass with `heading` and `body` fields
4. **Error handling**: Map Rust errors to Python exceptions (`MarkdownExtractError`)
5. **Type stubs**: Generate `.pyi` files for type checkers
6. **Tests**: Python unit tests + PyO3 integration tests
7. **Build config**: Basic `maturin` setup (defer full CI to M4)

### Out of Scope
- Full CLI parity (defer advanced regex options, stdin handling)
- Async APIs (sync-only for M1)
- MCP server implementation (M3)
- Cross-platform CI (M4)

---

## Technical Requirements

### API Surface

```python
# markdown_extract_py/__init__.py (generated by PyO3)

def extract(
    pattern: str,
    content: str,
    *,
    case_sensitive: bool = False,
    all_matches: bool = False,
    no_heading: bool = False,
) -> list[str]:
    """
    Extract sections from Markdown content matching the regex pattern.
    
    Args:
        pattern: Regex pattern to match against headings (without # markers)
        content: Markdown text to search
        case_sensitive: Exact pattern matching (default: case-insensitive)
        all_matches: Return all matches (default: first only)
        no_heading: Omit heading line from results (body only)
    
    Returns:
        List of section strings (heading + body unless no_heading=True)
    
    Raises:
        MarkdownExtractError: If pattern is invalid or extraction fails
    
    Example:
        >>> text = "# Intro\\nContent here\\n## Details\\nMore text"
        >>> extract("Details", text)
        ["## Details\\nMore text"]
    """
    ...

def extract_from_file(
    pattern: str,
    path: str,
    *,
    case_sensitive: bool = False,
    all_matches: bool = False,
    no_heading: bool = False,
) -> list[str]:
    """
    Extract sections from a Markdown file matching the regex pattern.
    
    Args:
        pattern: Regex pattern to match against headings
        path: Path to markdown file (absolute or relative)
        case_sensitive: Exact pattern matching
        all_matches: Return all matches
        no_heading: Omit heading line from results
    
    Returns:
        List of section strings
    
    Raises:
        MarkdownExtractError: If file not found, invalid UTF-8, or extraction fails
    
    Example:
        >>> extract_from_file("Installation", "README.md")
        ["## Installation\\n..."]
    """
    ...

class MarkdownExtractError(Exception):
    """Raised when extraction fails (invalid pattern, I/O error, etc)."""
    pass
```

### Optional Structured API (Stretch Goal)

```python
@dataclass
class Section:
    """Extracted markdown section with parsed components."""
    heading: str        # Full heading line (e.g., "## Title")
    level: int          # Heading depth (1-6)
    title: str          # Heading text without markers
    body: str           # Section content (excluding heading)
    full_text: str      # Heading + body

def extract_sections(
    pattern: str,
    content: str,
    **options,
) -> list[Section]:
    """Extract sections with structured metadata."""
    ...
```
- If the structured API is implemented, define a `#[pyclass]` with `#[pyo3(get)]` accessors or convert to `PyDict` before returning.

---

## Implementation Steps

1. **Crate scaffolding**
   ```bash
   cargo new --lib crates/markdown_extract_py
   ```
   - Add PyO3 dependency to `Cargo.toml`:
     ```toml
     [lib]
     name = "markdown_extract_py"
     crate-type = ["cdylib"]
     
     [dependencies]
     pyo3 = { version = "0.20", features = ["extension-module"] }
     markdown-extract = { path = "../markdown-extract" }
     regex = "1.10"
     ```
   - Import the library crate under its underscore name (e.g., `use markdown_extract::extract_from_reader;`).

2. **Core binding implementation**
   - Use `#[pyfunction]` for `extract` and `extract_from_file`
   - Use `#[pymodule]` to define the Python module
   - Compile the pattern with `RegexBuilder::new(pattern)?.case_insensitive(!case_sensitive).unicode(true).build()?`
   - Wrap `markdown_extract::extract_from_reader` with Python string/path handling
   - Join each returned `Vec<String>` into a single string; implement `no_heading` by dropping the first line when requested
   - Ensure `all_matches=False` only returns the first section to preserve CLI parity

3. **Error handling**
   - Define a custom `MarkdownExtractError` deriving `From` for common failure types
   - Map I/O errors to the closest Python built-in (`PyFileNotFoundError`, `PyPermissionError`, `PyRuntimeError` fallback)
   - Map regex compilation errors to `PyValueError`
   - Preserve original error messages for debugging

4. **Type stubs generation**
   - Use `maturin develop` to build locally
   - Either hand-author `python/markdown_extract_py/__init__.pyi` or run `pyo3-stub-gen` (mark as optional in README)
   - Validate with `mypy` and `pyright`; store stubs alongside the package code

5. **Testing**
   - **Rust side**: `#[cfg(test)]` modules testing PyO3 function signatures
     - Use the generated `PyResult` return types and assert via `Python::with_gil`
     - Use `Python::with_gil` in Rust tests when calling into bindings
   - **Python side**: `tests/test_extract.py` with pytest
     - Test basic extraction
     - Test `all_matches` flag
     - Test `no_heading` flag
     - Test error cases (invalid pattern, missing file, invalid UTF-8)
     - Test case sensitivity

6. **Build configuration**
   ```toml
   # pyproject.toml
   [build-system]
   requires = ["maturin>=1.0,<2.0"]
   build-backend = "maturin"
   
   [project]
   name = "markdown-extract-py"
   requires-python = ">=3.8"
   classifiers = [
       "Programming Language :: Rust",
       "Programming Language :: Python :: Implementation :: CPython",
   ]
   ```
   - Place this `pyproject.toml` alongside the Python package sources (e.g., `python/markdown_extract_py/pyproject.toml`)
   - Gate the `extension-module` feature behind `cfg` if necessary for future binary-only builds
   - Note required platform setup (e.g., `python3.X-dev` headers, `PYO3_CONFIG_FILE` for Windows/macOS) so CI can adopt it in later milestones

---

## Deliverables

- [ ] `crates/markdown_extract_py/` crate with PyO3 bindings
- [ ] `extract()` and `extract_from_file()` functions working
- [ ] `MarkdownExtractError` exception class
- [ ] Type stub file (`.pyi`) for IDE/type checker support
- [ ] Python test suite (`tests/test_extract.py`) with ≥90% coverage
- [ ] `pyproject.toml` and `Cargo.toml` configured for maturin
- [ ] README with installation and usage examples
- [ ] Inline API documentation (docstrings)

---

## Testing Strategy

### Rust-Level Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_extract_basic() {
        let content = "# Title\nIntro\n## Section\nContent";
        let result = extract("Section", content, false, false, false).unwrap();
        assert_eq!(result.len(), 1);
        assert!(result[0].contains("## Section"));
    }
}
```

### Python-Level Tests
```python
# tests/test_extract.py
import pytest
import markdown_extract_py as mde

def test_extract_basic():
    content = "# Title\nIntro\n## Section\nContent"
    result = mde.extract("Section", content)
    assert len(result) == 1
    assert "## Section" in result[0]

def test_extract_all_matches():
    content = "# A\n## B\n# A\n## C"
    result = mde.extract("A", content, all_matches=True)
    assert len(result) == 2

def test_extract_no_heading():
    content = "## Title\nBody text"
    result = mde.extract("Title", content, no_heading=True)
    assert "## Title" not in result[0]
    assert "Body text" in result[0]

def test_extract_invalid_pattern():
    with pytest.raises(mde.MarkdownExtractError):
        mde.extract("[invalid(", "content")

def test_extract_from_file_not_found():
    with pytest.raises(mde.MarkdownExtractError):
        mde.extract_from_file("pattern", "nonexistent.md")
```

---

## Acceptance Criteria

- [ ] `maturin develop` builds successfully
- [ ] `import markdown_extract_py; markdown_extract_py.extract(...)` works in Python REPL
- [ ] All pytest tests pass
- [ ] Type stubs validate with `mypy --strict`
- [ ] Performance within 15% of CLI subprocess call (benchmark)
- [ ] Error messages are clear and actionable
- [ ] README includes quick start example

---

## Resources

- [PyO3 Guide: Python Functions](https://pyo3.rs/v0.20.0/function.html)
- [PyO3 Guide: Exception Handling](https://pyo3.rs/v0.20.0/exception.html)
- [maturin User Guide](https://www.maturin.rs/)
- [markdown-extract library docs](../../../crates/markdown-extract/)

---

## Handoff Notes

**Context for next agent (M2)**:
- Reuse binding patterns from `markdown_extract_py` for `markdown_edit_py`
- Consider unifying error types across all `*_py` crates
- Type stub generation should be automated in CI (defer to M4)

**Files to reference**:
- `crates/markdown-extract/src/lib.rs` – existing Rust API
- `crates/markdown-extract-cli/src/main.rs` – CLI flag mappings
- `tests/markdown/*.md` – test fixtures

**Open questions**:
- Should we expose regex compilation separately for reuse?
- Do we need streaming APIs for large files? (defer if not needed)
